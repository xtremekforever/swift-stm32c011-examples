// Generated by svd2swift.

import MMIO

/// RCC address block description
@RegisterBlock
public struct RCC: Sendable {
    /// RCC clock control register
    @RegisterBlock(offset: 0x0)
    public var cr: Register<CR>

    /// RCC internal clock source calibration register
    @RegisterBlock(offset: 0x4)
    public var icscr: Register<ICSCR>

    /// RCC clock configuration register
    @RegisterBlock(offset: 0x8)
    public var cfgr: Register<CFGR>

    /// RCC clock interrupt enable register
    @RegisterBlock(offset: 0x18)
    public var cier: Register<CIER>

    /// RCC clock interrupt flag register
    @RegisterBlock(offset: 0x1c)
    public var cifr: Register<CIFR>

    /// RCC clock interrupt clear register
    @RegisterBlock(offset: 0x20)
    public var cicr: Register<CICR>

    /// RCC I/O port reset register
    @RegisterBlock(offset: 0x24)
    public var ioprstr: Register<IOPRSTR>

    /// RCC AHB peripheral reset register
    @RegisterBlock(offset: 0x28)
    public var ahbrstr: Register<AHBRSTR>

    /// RCC APB peripheral reset register 1
    @RegisterBlock(offset: 0x2c)
    public var apbrstr1: Register<APBRSTR1>

    /// RCC APB peripheral reset register 2
    @RegisterBlock(offset: 0x30)
    public var apbrstr2: Register<APBRSTR2>

    /// RCC I/O port clock enable register
    @RegisterBlock(offset: 0x34)
    public var iopenr: Register<IOPENR>

    /// RCC AHB peripheral clock enable register
    @RegisterBlock(offset: 0x38)
    public var ahbenr: Register<AHBENR>

    /// RCC APB peripheral clock enable register 1
    @RegisterBlock(offset: 0x3c)
    public var apbenr1: Register<APBENR1>

    /// RCC APB peripheral clock enable register 2
    @RegisterBlock(offset: 0x40)
    public var apbenr2: Register<APBENR2>

    /// RCC I/O port in Sleep mode clock enable register
    @RegisterBlock(offset: 0x44)
    public var iopsmenr: Register<IOPSMENR>

    /// RCC AHB peripheral clock enable in Sleep/Stop mode register
    @RegisterBlock(offset: 0x48)
    public var ahbsmenr: Register<AHBSMENR>

    /// RCC APB peripheral clock enable in Sleep/Stop mode register 1
    @RegisterBlock(offset: 0x4c)
    public var apbsmenr1: Register<APBSMENR1>

    /// RCC APB peripheral clock enable in Sleep/Stop mode register 2
    @RegisterBlock(offset: 0x50)
    public var apbsmenr2: Register<APBSMENR2>

    /// RCC peripherals independent clock configuration register
    @RegisterBlock(offset: 0x54)
    public var ccipr: Register<CCIPR>

    /// RCC control/status register 1
    @RegisterBlock(offset: 0x5c)
    public var csr1: Register<CSR1>

    /// RCC control/status register 2
    @RegisterBlock(offset: 0x60)
    public var csr2: Register<CSR2>
}

extension RCC {
    /// RCC clock control register
    @Register(bitWidth: 32)
    public struct CR {
        /// System clock division factor
        /// This bitfield controlled by software sets the division factor of the system clock divider to produce SYSCLK clock:
        @ReadWrite(bits: 2..<5)
        public var sysdiv: SYSDIV

        /// HSI48 kernel clock division factor
        /// This bitfield controlled by software sets the division factor of the kernel clock divider to produce HSIKER clock:
        @ReadWrite(bits: 5..<8)
        public var hsikerdiv: HSIKERDIV

        /// HSI48 clock enable
        /// Set and cleared by software and hardware, with hardware taking priority.
        /// Kept low by hardware as long as the device is in a low-power mode.
        /// Kept high by hardware as long as the system is clocked with a clock derived from HSI48. This includes the exit from low-power modes and the system clock fall-back to HSI48 upon failing HSE oscillator clock selected as system clock source.
        @ReadWrite(bits: 8..<9)
        public var hsion: HSION

        /// HSI48 always-enable for peripheral kernels.
        /// Set and cleared by software.
        /// Setting the bit activates the HSI48 oscillator in Run and Stop modes, regardless of the HSION bit state. The HSI48 clock can only feed USART1, USART2, and I2C1 peripherals configured with HSI48 as kernel clock.
        /// Note: Keeping the HSI48 active in Stop mode allows speeding up the serial interface communication as the HSI48 clock is ready immediately upon exiting Stop mode.
        @ReadWrite(bits: 9..<10)
        public var hsikeron: HSIKERON

        /// HSI48 clock ready flag
        /// Set by hardware when the HSI48 oscillator is enabled through HSION and ready to use (stable).
        /// Note: Upon clearing HSION, HSIRDY goes low after six HSI48 clock cycles.
        @ReadOnly(bits: 10..<11)
        public var hsirdy: HSIRDY

        /// HSI48 clock division factor
        /// This bitfield controlled by software sets the division factor of the HSI48 clock divider to produce HSISYS clock:
        @ReadWrite(bits: 11..<14)
        public var hsidiv: HSIDIV

        /// HSE clock enable
        /// Set and cleared by software.
        /// Cleared by hardware to stop the HSE oscillator when entering Stop, or Standby, or Shutdown mode. This bit cannot be cleared if the HSE oscillator is used directly or indirectly as the system clock.
        @ReadWrite(bits: 16..<17)
        public var hseon: HSEON

        /// HSE clock ready flag
        /// Set by hardware to indicate that the HSE oscillator is stable and ready for use.
        /// Note: Upon clearing HSEON, HSERDY goes low after six HSE clock cycles.
        @ReadOnly(bits: 17..<18)
        public var hserdy: HSERDY

        /// HSE crystal oscillator bypass
        /// Set and cleared by software.
        /// When the bit is set, the internal HSE oscillator is bypassed for use of an external clock. The external clock must then be enabled with the HSEON bit set. Write access to the bit is only effective when the HSE oscillator is disabled.
        @ReadWrite(bits: 18..<19)
        public var hsebyp: HSEBYP

        /// Clock security system enable
        /// Set by software to enable the clock security system. When the bit is set, the clock detector is enabled by hardware when the HSE oscillator is ready, and disabled by hardware if a HSE clock failure is detected. The bit is cleared by hardware upon reset.
        @ReadWrite(bits: 19..<20)
        public var csson: CSSON
    }

    /// RCC internal clock source calibration register
    @Register(bitWidth: 32)
    public struct ICSCR {
        /// HSI48 clock calibration
        /// This bitfield directly acts on the HSI48 clock frequency. Its value is a sum of an internal factory-programmed number and the value of the HSITRIM[6:0] bitfield. In the factory, the internal number is set to calibrate the HSI48 clock frequency to 48 MHz (with HSITRIM[6:0] left at its reset value). Refer to the device datasheet for HSI48 calibration accuracy and for the frequency trimming granularity.
        /// Note: The trimming effect presents discontinuities at HSICAL[7:0] multiples of 64.
        @ReadOnly(bits: 0..<8)
        public var hsical: HSICAL

        /// HSI48 clock trimming
        /// The value of this bitfield contributes to the HSICAL[7:0] bitfield value.
        /// It allows HSI48 clock frequency user trimming.
        /// The HSI48 frequency accuracy as stated in the device datasheet applies when this bitfield is left at its reset value.
        @ReadWrite(bits: 8..<15)
        public var hsitrim: HSITRIM
    }

    /// RCC clock configuration register
    @Register(bitWidth: 32)
    public struct CFGR {
        /// System clock switch
        /// This bitfield is controlled by software and hardware. The bitfield selects the clock for SYSCLK as follows:
        /// Others: Reserved
        /// The setting is forced by hardware to 000 (HSISYS selected) when the MCU exits Stop, or Standby, or Shutdown mode, or when the setting is 001 (HSE selected) and HSE oscillator failure is detected.
        @ReadWrite(bits: 0..<3)
        public var sw: SW

        /// System clock switch status
        /// This bitfield is controlled by hardware to indicate the clock source used as system clock:
        /// Others: Reserved
        @ReadOnly(bits: 3..<6)
        public var sws: SWS

        /// AHB prescaler
        /// This bitfield is controlled by software. To produce HCLK clock, it sets the division factor of SYSCLK clock as follows:
        /// 0xxx: 1
        @ReadWrite(bits: 8..<12)
        public var hpre: HPRE

        /// APB prescaler
        /// This bitfield is controlled by software. To produce PCLK clock, it sets the division factor of HCLK clock as follows:
        /// 0xx: 1
        @ReadWrite(bits: 12..<15)
        public var ppre: PPRE

        /// Microcontroller clock output 2 clock selector
        /// This bitfield is controlled by software. It sets the clock selector for MCO2 output as follows:
        /// This bitfield is controlled by software. It sets the clock selector for MCO output as follows:
        /// Note: This clock output may have some truncated cycles at startup or during MCO2 clock source switching.
        @ReadWrite(bits: 16..<20)
        public var mco2sel: MCO2SEL

        /// Microcontroller clock output 2 prescaler
        /// This bitfield is controlled by software. It sets the division factor of the clock sent to the MCO2 output as follows:
        /// ...
        /// It is highly recommended to set this field before the MCO2 output is enabled.
        @ReadWrite(bits: 20..<24)
        public var mco2pre: MCO2PRE

        /// Microcontroller clock output clock selector
        /// This bitfield is controlled by software. It sets the clock selector for MCO output as follows:
        /// Note: This clock output may have some truncated cycles at startup or during MCO clock source switching. Any other value means no clock on MCO.
        @ReadWrite(bits: 24..<28)
        public var mcosel: MCOSEL

        /// Microcontroller clock output prescaler
        /// This bitfield is controlled by software. It sets the division factor of the clock sent to the MCO output as follows:
        /// ...
        /// It is highly recommended to set this field before the MCO output is enabled.
        @ReadWrite(bits: 28..<32)
        public var mcopre: MCOPRE
    }

    /// RCC clock interrupt enable register
    @Register(bitWidth: 32)
    public struct CIER {
        /// LSI ready interrupt enable
        /// Set and cleared by software to enable/disable interrupt caused by the LSI oscillator stabilization:
        @ReadWrite(bits: 0..<1)
        public var lsirdyie: LSIRDYIE

        /// LSE ready interrupt enable
        /// Set and cleared by software to enable/disable interrupt caused by the LSE oscillator stabilization:
        @ReadWrite(bits: 1..<2)
        public var lserdyie: LSERDYIE

        /// HSI16 ready interrupt enable
        /// Set and cleared by software to enable/disable interrupt caused by the HSI16 oscillator stabilization:
        @ReadWrite(bits: 3..<4)
        public var hsirdyie: HSIRDYIE

        /// HSE ready interrupt enable
        /// Set and cleared by software to enable/disable interrupt caused by the HSE oscillator stabilization:
        @ReadWrite(bits: 4..<5)
        public var hserdyie: HSERDYIE
    }

    /// RCC clock interrupt flag register
    @Register(bitWidth: 32)
    public struct CIFR {
        /// LSI ready interrupt flag
        /// This flag indicates a pending interrupt upon LSE clock getting ready.
        /// Set by hardware when the LSI clock becomes stable and LSIRDYDIE is set.
        /// Cleared by software setting the LSIRDYC bit.
        @ReadOnly(bits: 0..<1)
        public var lsirdyf: LSIRDYF

        /// LSE ready interrupt flag
        /// This flag indicates a pending interrupt upon LSE clock getting ready.
        /// Set by hardware when the LSE clock becomes stable and LSERDYDIE is set.
        /// Cleared by software setting the LSERDYC bit.
        @ReadOnly(bits: 1..<2)
        public var lserdyf: LSERDYF

        /// HSI16 ready interrupt flag
        /// This flag indicates a pending interrupt upon HSI16 clock getting ready.
        /// Set by hardware when the HSI16 clock becomes stable and HSIRDYIE is set in response to setting the HSION (refer to ). When HSION is not set but the HSI16 oscillator is enabled by the peripheral through a clock request, this bit is not set and no interrupt is generated.
        /// Cleared by software setting the HSIRDYC bit.
        @ReadOnly(bits: 3..<4)
        public var hsirdyf: HSIRDYF

        /// HSE ready interrupt flag
        /// This flag indicates a pending interrupt upon HSE clock getting ready.
        /// Set by hardware when the HSE clock becomes stable and HSERDYIE is set.
        /// Cleared by software setting the HSERDYC bit.
        @ReadOnly(bits: 4..<5)
        public var hserdyf: HSERDYF

        /// HSE clock security system interrupt flag
        /// This flag indicates a pending interrupt upon HSE clock failure.
        /// Set by hardware when a failure is detected in the HSE oscillator.
        /// Cleared by software setting the CSSC bit.
        @ReadOnly(bits: 8..<9)
        public var cssf: CSSF

        /// LSE clock security system interrupt flag
        /// This flag indicates a pending interrupt upon LSE clock failure.
        /// Set by hardware when a failure is detected in the LSE oscillator.
        /// Cleared by software by setting the LSECSSC bit.
        @ReadOnly(bits: 9..<10)
        public var lsecssf: LSECSSF
    }

    /// RCC clock interrupt clear register
    @Register(bitWidth: 32)
    public struct CICR {
        /// LSI ready interrupt clear
        /// This bit is set by software to clear the LSIRDYF flag.
        @WriteOnly(bits: 0..<1)
        public var lsirdyc: LSIRDYC

        /// LSE ready interrupt clear
        /// This bit is set by software to clear the LSERDYF flag.
        @WriteOnly(bits: 1..<2)
        public var lserdyc: LSERDYC

        /// HSI16 ready interrupt clear
        /// This bit is set software to clear the HSIRDYF flag.
        @WriteOnly(bits: 3..<4)
        public var hsirdyc: HSIRDYC

        /// HSE ready interrupt clear
        /// This bit is set by software to clear the HSERDYF flag.
        @WriteOnly(bits: 4..<5)
        public var hserdyc: HSERDYC

        /// Clock security system interrupt clear
        /// This bit is set by software to clear the HSECSSF flag.
        @WriteOnly(bits: 8..<9)
        public var cssc: CSSC

        /// LSE Clock security system interrupt clear
        /// This bit is set by software to clear the LSECSSF flag.
        @WriteOnly(bits: 9..<10)
        public var lsecssc: LSECSSC
    }

    /// RCC I/O port reset register
    @Register(bitWidth: 32)
    public struct IOPRSTR {
        /// I/O port A reset
        /// This bit is set and cleared by software.
        @ReadWrite(bits: 0..<1)
        public var gpioarst: GPIOARST

        /// I/O port B reset
        /// This bit is set and cleared by software.
        @ReadWrite(bits: 1..<2)
        public var gpiobrst: GPIOBRST

        /// I/O port C reset
        /// This bit is set and cleared by software.
        @ReadWrite(bits: 2..<3)
        public var gpiocrst: GPIOCRST

        /// I/O port D reset
        /// This bit is set and cleared by software.
        @ReadWrite(bits: 3..<4)
        public var gpiodrst: GPIODRST

        /// I/O port F reset
        /// This bit is set and cleared by software.
        @ReadWrite(bits: 5..<6)
        public var gpiofrst: GPIOFRST
    }

    /// RCC AHB peripheral reset register
    @Register(bitWidth: 32)
    public struct AHBRSTR {
        /// DMA1 and DMAMUX reset
        /// Set and cleared by software.
        @ReadWrite(bits: 0..<1)
        public var dma1rst: DMA1RST

        /// Flash memory interface reset
        /// Set and cleared by software.
        /// This bit can only be set when the Flash memory is in power down mode.
        @ReadWrite(bits: 8..<9)
        public var flashrst: FLASHRST

        /// CRC reset
        /// Set and cleared by software.
        @ReadWrite(bits: 12..<13)
        public var crcrst: CRCRST
    }

    /// RCC APB peripheral reset register 1
    @Register(bitWidth: 32)
    public struct APBRSTR1 {
        /// TIM3 timer reset
        /// Set and cleared by software.
        @ReadWrite(bits: 1..<2)
        public var tim3rst: TIM3RST

        /// USART2 reset
        /// Set and cleared by software.
        @ReadWrite(bits: 17..<18)
        public var usart2rst: USART2RST

        /// I2C1 reset
        /// Set and cleared by software.
        @ReadWrite(bits: 21..<22)
        public var i2c1rst: I2C1RST

        /// Debug support reset
        /// Set and cleared by software.
        @ReadWrite(bits: 27..<28)
        public var dbgrst: DBGRST

        /// Power interface reset
        /// Set and cleared by software.
        @ReadWrite(bits: 28..<29)
        public var pwrrst: PWRRST
    }

    /// RCC APB peripheral reset register 2
    @Register(bitWidth: 32)
    public struct APBRSTR2 {
        /// SYSCFG reset
        /// Set and cleared by software.
        @ReadWrite(bits: 0..<1)
        public var syscfgrst: SYSCFGRST

        /// TIM1 timer reset
        /// Set and cleared by software.
        @ReadWrite(bits: 11..<12)
        public var tim1rst: TIM1RST

        /// SPI1 reset
        /// Set and cleared by software.
        @ReadWrite(bits: 12..<13)
        public var spi1rst: SPI1RST

        /// USART1 reset
        /// Set and cleared by software.
        @ReadWrite(bits: 14..<15)
        public var usart1rst: USART1RST

        /// TIM14 timer reset
        /// Set and cleared by software.
        @ReadWrite(bits: 15..<16)
        public var tim14rst: TIM14RST

        /// TIM16 timer reset
        /// Set and cleared by software.
        @ReadWrite(bits: 17..<18)
        public var tim16rst: TIM16RST

        /// TIM16 timer reset
        /// Set and cleared by software.
        @ReadWrite(bits: 18..<19)
        public var tim17rst: TIM17RST

        /// ADC reset
        /// Set and cleared by software.
        @ReadWrite(bits: 20..<21)
        public var adcrst: ADCRST
    }

    /// RCC I/O port clock enable register
    @Register(bitWidth: 32)
    public struct IOPENR {
        /// I/O port A clock enable
        /// This bit is set and cleared by software.
        @ReadWrite(bits: 0..<1)
        public var gpioaen: GPIOAEN

        /// I/O port B clock enable
        /// This bit is set and cleared by software.
        @ReadWrite(bits: 1..<2)
        public var gpioben: GPIOBEN

        /// I/O port C clock enable
        /// This bit is set and cleared by software.
        @ReadWrite(bits: 2..<3)
        public var gpiocen: GPIOCEN

        /// I/O port D clock enable
        /// This bit is set and cleared by software.
        @ReadWrite(bits: 3..<4)
        public var gpioden: GPIODEN

        /// I/O port F clock enable
        /// This bit is set and cleared by software.
        @ReadWrite(bits: 5..<6)
        public var gpiofen: GPIOFEN
    }

    /// RCC AHB peripheral clock enable register
    @Register(bitWidth: 32)
    public struct AHBENR {
        /// DMA1 and DMAMUX clock enable
        /// Set and cleared by software.
        /// DMAMUX is enabled as long as at least one DMA peripheral is enabled.
        @ReadWrite(bits: 0..<1)
        public var dma1en: DMA1EN

        /// Flash memory interface clock enable
        /// Set and cleared by software.
        /// This bit can only be cleared when the Flash memory is in power down mode.
        @ReadWrite(bits: 8..<9)
        public var flashen: FLASHEN

        /// CRC clock enable
        /// Set and cleared by software.
        @ReadWrite(bits: 12..<13)
        public var crcen: CRCEN
    }

    /// RCC APB peripheral clock enable register 1
    @Register(bitWidth: 32)
    public struct APBENR1 {
        /// TIM3 timer clock enable
        /// Set and cleared by software.
        @ReadWrite(bits: 1..<2)
        public var tim3en: TIM3EN

        /// RTC APB clock enable
        /// Set and cleared by software.
        @ReadWrite(bits: 10..<11)
        public var rtcapben: RTCAPBEN

        /// WWDG clock enable
        /// Set by software to enable the window watchdog clock. Cleared by hardware system reset
        /// This bit can also be set by hardware if the WWDG_SW option bit is 0.
        @ReadWrite(bits: 11..<12)
        public var wwdgen: WWDGEN

        /// USART2 clock enable
        /// Set and cleared by software.
        @ReadWrite(bits: 17..<18)
        public var usart2en: USART2EN

        /// I2C1 clock enable
        /// Set and cleared by software.
        @ReadWrite(bits: 21..<22)
        public var i2c1en: I2C1EN

        /// Debug support clock enable
        /// Set and cleared by software.
        @ReadWrite(bits: 27..<28)
        public var dbgen: DBGEN

        /// Power interface clock enable
        /// Set and cleared by software.
        @ReadWrite(bits: 28..<29)
        public var pwren: PWREN
    }

    /// RCC APB peripheral clock enable register 2
    @Register(bitWidth: 32)
    public struct APBENR2 {
        /// SYSCFG clock enable
        /// Set and cleared by software.
        @ReadWrite(bits: 0..<1)
        public var syscfgen: SYSCFGEN

        /// TIM1 timer clock enable
        /// Set and cleared by software.
        @ReadWrite(bits: 11..<12)
        public var tim1en: TIM1EN

        /// SPI1 clock enable
        /// Set and cleared by software.
        @ReadWrite(bits: 12..<13)
        public var spi1en: SPI1EN

        /// USART1 clock enable
        /// Set and cleared by software.
        @ReadWrite(bits: 14..<15)
        public var usart1en: USART1EN

        /// TIM14 timer clock enable
        /// Set and cleared by software.
        @ReadWrite(bits: 15..<16)
        public var tim14en: TIM14EN

        /// TIM16 timer clock enable
        /// Set and cleared by software.
        @ReadWrite(bits: 17..<18)
        public var tim16en: TIM16EN

        /// TIM16 timer clock enable
        /// Set and cleared by software.
        @ReadWrite(bits: 18..<19)
        public var tim17en: TIM17EN

        /// ADC clock enable
        /// Set and cleared by software.
        @ReadWrite(bits: 20..<21)
        public var adcen: ADCEN
    }

    /// RCC I/O port in Sleep mode clock enable register
    @Register(bitWidth: 32)
    public struct IOPSMENR {
        /// I/O port A clock enable during Sleep mode
        /// Set and cleared by software.
        @ReadWrite(bits: 0..<1)
        public var gpioasmen: GPIOASMEN

        /// I/O port B clock enable during Sleep mode
        /// Set and cleared by software.
        @ReadWrite(bits: 1..<2)
        public var gpiobsmen: GPIOBSMEN

        /// I/O port C clock enable during Sleep mode
        /// Set and cleared by software.
        @ReadWrite(bits: 2..<3)
        public var gpiocsmen: GPIOCSMEN

        /// I/O port D clock enable during Sleep mode
        /// Set and cleared by software.
        @ReadWrite(bits: 3..<4)
        public var gpiodsmen: GPIODSMEN

        /// I/O port F clock enable during Sleep mode
        /// Set and cleared by software.
        @ReadWrite(bits: 5..<6)
        public var gpiofsmen: GPIOFSMEN
    }

    /// RCC AHB peripheral clock enable in Sleep/Stop mode register
    @Register(bitWidth: 32)
    public struct AHBSMENR {
        /// DMA1 and DMAMUX clock enable during Sleep mode
        /// Set and cleared by software.
        /// Clock to DMAMUX during Sleep mode is enabled as long as the clock in Sleep mode is enabled to at least one DMA peripheral.
        @ReadWrite(bits: 0..<1)
        public var dma1smen: DMA1SMEN

        /// Flash memory interface clock enable during Sleep mode
        /// Set and cleared by software.
        /// This bit can be activated only when the Flash memory is in power down mode.
        @ReadWrite(bits: 8..<9)
        public var flashsmen: FLASHSMEN

        /// SRAM clock enable during Sleep mode
        /// Set and cleared by software.
        @ReadWrite(bits: 9..<10)
        public var sramsmen: SRAMSMEN

        /// CRC clock enable during Sleep mode
        /// Set and cleared by software.
        @ReadWrite(bits: 12..<13)
        public var crcsmen: CRCSMEN
    }

    /// RCC APB peripheral clock enable in Sleep/Stop mode register 1
    @Register(bitWidth: 32)
    public struct APBSMENR1 {
        /// TIM3 timer clock enable during Sleep mode
        /// Set and cleared by software.
        @ReadWrite(bits: 1..<2)
        public var tim3smen: TIM3SMEN

        /// RTC APB clock enable during Sleep mode
        /// Set and cleared by software.
        @ReadWrite(bits: 10..<11)
        public var rtcapbsmen: RTCAPBSMEN

        /// WWDG clock enable during Sleep and Stop modes
        /// Set and cleared by software.
        @ReadWrite(bits: 11..<12)
        public var wwdgsmen: WWDGSMEN

        /// USART2 clock enable during Sleep and Stop modes
        /// Set and cleared by software.
        @ReadWrite(bits: 17..<18)
        public var usart2smen: USART2SMEN

        /// I2C1 clock enable during Sleep and Stop modes
        /// Set and cleared by software.
        @ReadWrite(bits: 21..<22)
        public var i2c1smen: I2C1SMEN

        /// Debug support clock enable during Sleep mode
        /// Set and cleared by software.
        @ReadWrite(bits: 27..<28)
        public var dbgsmen: DBGSMEN

        /// Power interface clock enable during Sleep mode
        /// Set and cleared by software.
        @ReadWrite(bits: 28..<29)
        public var pwrsmen: PWRSMEN
    }

    /// RCC APB peripheral clock enable in Sleep/Stop mode register 2
    @Register(bitWidth: 32)
    public struct APBSMENR2 {
        /// SYSCFG clock enable during Sleep and Stop modes
        /// Set and cleared by software.
        @ReadWrite(bits: 0..<1)
        public var syscfgsmen: SYSCFGSMEN

        /// TIM1 timer clock enable during Sleep mode
        /// Set and cleared by software.
        @ReadWrite(bits: 11..<12)
        public var tim1smen: TIM1SMEN

        /// SPI1 clock enable during Sleep mode
        /// Set and cleared by software.
        @ReadWrite(bits: 12..<13)
        public var spi1smen: SPI1SMEN

        /// USART1 clock enable during Sleep and Stop modes
        /// Set and cleared by software.
        @ReadWrite(bits: 14..<15)
        public var usart1smen: USART1SMEN

        /// TIM14 timer clock enable during Sleep mode
        /// Set and cleared by software.
        @ReadWrite(bits: 15..<16)
        public var tim14smen: TIM14SMEN

        /// TIM16 timer clock enable during Sleep mode
        /// Set and cleared by software.
        @ReadWrite(bits: 17..<18)
        public var tim16smen: TIM16SMEN

        /// TIM16 timer clock enable during Sleep mode
        /// Set and cleared by software.
        @ReadWrite(bits: 18..<19)
        public var tim17smen: TIM17SMEN

        /// ADC clock enable during Sleep mode
        /// Set and cleared by software.
        @ReadWrite(bits: 20..<21)
        public var adcsmen: ADCSMEN
    }

    /// RCC peripherals independent clock configuration register
    @Register(bitWidth: 32)
    public struct CCIPR {
        /// USART1 clock source selection
        /// This bitfield is controlled by software to select USART1 clock source as follows:
        @ReadWrite(bits: 0..<2)
        public var usart1sel: USART1SEL

        /// I2C1 clock source selection
        /// This bitfield is controlled by software to select I2C1 clock source as follows:
        @ReadWrite(bits: 12..<14)
        public var i2c1sel: I2C1SEL

        /// I2S1 clock source selection
        /// This bitfield is controlled by software to select I2S1 clock source as follows:
        @ReadWrite(bits: 14..<16)
        public var i2s1sel: I2S1SEL

        /// ADCs clock source selection
        /// This bitfield is controlled by software to select the clock source for ADC:
        @ReadWrite(bits: 30..<32)
        public var adcsel: ADCSEL
    }

    /// RCC control/status register 1
    @Register(bitWidth: 32)
    public struct CSR1 {
        /// LSE oscillator enable
        /// Set and cleared by software to enable LSE oscillator:
        @ReadWrite(bits: 0..<1)
        public var lseon: LSEON

        /// LSE oscillator ready
        /// Set and cleared by hardware to indicate when the external 32 kHz oscillator is ready (stable):
        /// After the LSEON bit is cleared, LSERDY goes low after 6 external low-speed oscillator clock cycles.
        @ReadOnly(bits: 1..<2)
        public var lserdy: LSERDY

        /// LSE oscillator bypass
        /// Set and cleared by software to bypass the LSE oscillator (in debug mode).
        /// This bit can be written only when the external 32 kHz oscillator is disabled (LSEON=0 and LSERDY=0).
        @ReadWrite(bits: 2..<3)
        public var lsebyp: LSEBYP

        /// LSE oscillator drive capability
        /// Set by software to select the LSE oscillator drive capability as follows:
        /// Applicable when the LSE oscillator is in Xtal mode, as opposed to bypass mode.
        @ReadWrite(bits: 3..<5)
        public var lsedrv: LSEDRV

        /// CSS on LSE enable
        /// Set by software to enable the clock security system on LSE (32 kHz) oscillator as follows:
        /// LSECSSON must be enabled after the LSE oscillator is enabled (LSEON bit enabled) and ready (LSERDY flag set by hardware), and after the RTCSEL bit is selected.
        /// Once enabled, this bit cannot be disabled, except after a LSE failure detection (LSECSSD
        /// =1). In that case the software must disable the LSECSSON bit.
        @ReadWrite(bits: 5..<6)
        public var lsecsson: LSECSSON

        /// CSS on LSE failure Detection
        /// Set by hardware to indicate when a failure is detected by the clock security system
        /// on the external 32 kHz oscillator (LSE):
        @ReadOnly(bits: 6..<7)
        public var lsecssd: LSECSSD

        /// RTC clock source selection
        /// Set by software to select the clock source for the RTC as follows:
        /// Once the RTC clock source is selected, it cannot be changed anymore unless the RTC domain is reset, or unless a failure is detected on LSE (LSECSSD is set). The RTCRST bit can be used to reset this bitfield to 00.
        @ReadWrite(bits: 8..<10)
        public var rtcsel: RTCSEL

        /// RTC clock enable
        /// Set and cleared by software. The bit enables clock to RTC and TAMP.
        @ReadWrite(bits: 15..<16)
        public var rtcen: RTCEN

        /// RTC domain software reset
        /// Set and cleared by software to reset the RTC domain:
        @ReadWrite(bits: 16..<17)
        public var rtcrst: RTCRST

        /// Low-speed clock output (LSCO) enable
        /// Set and cleared by software.
        @ReadWrite(bits: 24..<25)
        public var lscoen: LSCOEN

        /// Low-speed clock output selection
        /// Set and cleared by software to select the low-speed output clock:
        @ReadWrite(bits: 25..<26)
        public var lscosel: LSCOSEL
    }

    /// RCC control/status register 2
    @Register(bitWidth: 32)
    public struct CSR2 {
        /// LSI oscillator enable
        /// Set and cleared by software to enable/disable the LSI oscillator:
        @ReadWrite(bits: 0..<1)
        public var lsion: LSION

        /// LSI oscillator ready
        /// Set and cleared by hardware to indicate when the LSI oscillator is ready (stable):
        /// After the LSION bit is cleared, LSIRDY goes low after 3 LSI oscillator clock cycles. This bit can be set even if LSION = 0 if the LSI is requested by the Clock Security System on LSE, by the Independent Watchdog or by the RTC.
        @ReadOnly(bits: 1..<2)
        public var lsirdy: LSIRDY

        /// Remove reset flags
        /// Set by software to clear the reset flags.
        @ReadWrite(bits: 23..<24)
        public var rmvf: RMVF

        /// Option byte loader reset flag
        /// Set by hardware when a reset from the Option byte loading occurs.
        /// Cleared by setting the RMVF bit.
        @ReadOnly(bits: 25..<26)
        public var oblrstf: OBLRSTF

        /// Pin reset flag
        /// Set by hardware when a reset from the NRST pin occurs.
        /// Cleared by setting the RMVF bit.
        @ReadOnly(bits: 26..<27)
        public var pinrstf: PINRSTF

        /// BOR or POR/PDR flag
        /// Set by hardware when a BOR or POR/PDR occurs.
        /// Cleared by setting the RMVF bit.
        @ReadOnly(bits: 27..<28)
        public var pwrrstf: PWRRSTF

        /// Software reset flag
        /// Set by hardware when a software reset occurs.
        /// Cleared by setting the RMVF bit.
        @ReadOnly(bits: 28..<29)
        public var sftrstf: SFTRSTF

        /// Independent window watchdog reset flag
        /// Set by hardware when an independent watchdog reset domain occurs.
        /// Cleared by setting the RMVF bit.
        @ReadOnly(bits: 29..<30)
        public var iwdgrstf: IWDGRSTF

        /// Window watchdog reset flag
        /// Set by hardware when a window watchdog reset occurs.
        /// Cleared by setting the RMVF bit.
        @ReadOnly(bits: 30..<31)
        public var wwdgrstf: WWDGRSTF

        /// Low-power reset flag
        /// Set by hardware when a reset occurs due to illegal Stop, or Standby, or Shutdown mode entry.
        /// Cleared by setting the RMVF bit.
        /// This operates only if nRST_STOP, or nRST_STDBY or nRST_SHDW option bits are cleared.
        @ReadOnly(bits: 31..<32)
        public var lpwrrstf: LPWRRSTF
    }
}
